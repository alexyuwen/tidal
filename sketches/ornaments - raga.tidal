

-- Define the whole scale ascending and descending, then use bite.
-- To couple dynamics to ornaments, are binary patterns needed?
let
scale0 = scale "minor" $ "<[0 2] [3 4] [7 4] [3 2]>"
ornamentRhythm0 = "[0@2 1 0@2 1@0.8 0@1.9] !"
ornamentRhythm1 = "[0@4 1 . 0]*4"
ornamentRhythm2 = "[0@1.9 1]*8"
scaleUp0 = scale "minor" $ "<[0 2] [3 4]>" + ornamentRhythm0 * "<[2 1] [1 3]>"
scaleDown0 = scale "minor" $ "<[7 4] [3 2]>" + ornamentRhythm0 * "<[2 3] [1 1]>"
scaleUpDown0 = sew "<t t f f>" scaleUp0 scaleDown0
scaleUp1 = scale "minor" $ "0 2 3 4" + ornamentRhythm1 * "2 1 1 3"
scaleDown1 = scale "minor" $ "7 4 3 2" + ornamentRhythm1 * "2 3 1 1"
scaleUp2 = scale "minor" $ "[0 2 3 4] !" + ornamentRhythm2 * "[3 2 4 5] !"
scaleDown2 = scale "minor" $ "[7 4 3 2] !" + ornamentRhythm2 * "[2 3 1 1] !"
scale2 = fastcat [scaleUp2, scaleDown2]
-- nPat = n (select ((/5) <$> "<0 0 1 1 2 3 [4 5]>") [scaleUp0, scaleDown0, scaleUp1, scaleDown1, scaleUp2, scaleDown2]) |+ n "d5"
nPat = outside 4 (bite 8 $ "0 1 2 3 4 5 6 7") $ n (scaleUpDown0 + "d5")
-- Wrap nPat in seqPLoop so that on the loop, all patterns reset to the start.
nPat2 = seqPLoop [
  (0, 7, nPat)
  ]
in do
  setcps 0.6
  setCycle 0
  d1 $ "cp" # gain 0.8
  d2 $ nPat2 # s "violin" # vowel "u"






-- Different set of ornaments.
let
scale0 = scale "minor" $ "<[0 2] [3 4] [7 4] [3 2]>"
ornamentRhythm0 = "[0@1.6 1@0.8 0@1.4 1@0.6 0@1.32] !"
ornamentRhythm1 = "[0@0.8 1 0@0.66]*4"
ornamentRhythm2 = "[0 1@1.1 0]*8"
scaleUp0 = scale "minor" $ "<[0 2] [3 4]>" + ornamentRhythm0 * "<[2 1] [1 3]>"
scaleDown0 = scale "minor" $ "<[7 4] [3 2]>" + ornamentRhythm0 * "<[2 3] [1 1]>"
scaleUp1 = scale "minor" $ "0 2 3 4" + ornamentRhythm1 * "2 1 1 3"
scaleDown1 = scale "minor" $ "7 4 3 2" + ornamentRhythm1 * "2 3 1 1"
scaleUp2 = scale "minor" $ "[0 2 3 4] !" + ornamentRhythm2 * "[2 1 1 3] !"
scaleDown2 = scale "minor" $ "[7 4 3 2] !" + ornamentRhythm2 * "[2 3 1 1] !"
scale2 = fastcat [scaleUp2, scaleDown2]
nPat = n (select ((/5) <$> "<0 0 1 1 2 3 [4 5]>") [scaleUp0, scaleDown0, scaleUp1, scaleDown1, scaleUp2, scaleDown2]) |+ n "d5"
-- Wrap nPat in seqPLoop so that on the loop, all patterns reset to the start.
nPat2 = seqPLoop [
  (0, 7, nPat)
  ]
in do
  setcps 0.6
  setCycle 0
  d1 $ "cp" # gain 0.8
  d2 $ nPat2 # s "violin" # vowel "u"





do
  setcps 0.6
  setCycle 0
  d1 $ "cp" # gain 0.8
  d2 $ outside 2 (bite 2 "1 0 1") $ n (scale "minor" "<[0..3] [4..7]>") # s "superhammond"
