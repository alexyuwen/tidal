

-- Define the whole scale ascending and descending, then use bite.
-- Use timecat for uneven rhythm, unless better solution exists?
let
scaleUp = (scale "minor" $ "0 2 3 4" + "[0@4 1 . 0]*4" * "2 1 1 3") + "d5"
scaleDown = (scale "minor" $ "7 4 3 2" + "[0@4 1 . 0]*4" * "2 3 1 1") + "d5"
in do
  d1 $ "cp" # gain 0.8
  d2 $ n (cat [scaleUp, scaleDown]) # s "violin" # vowel "u"



-- Ornaments.
let
notes = fast 2 <$> [
  (+ n "0 [0 1 . 0] 0 0") $ n (scale "major" "4 2 0 -3" |+ "d5"),
  (+ n "[0 -2 . 0] 0 0 0") $ n (scale "major" "2 4 7 9" |+ "g4"),
  (+ n "[2 0@2 2] 0 0 0") $ n (scale "major" "4 . 2 1" |+ "d5"),
  (+ n "0 . 0 [0 . -1 0]") $ n (scale "major" "0 . 2 3" |+ "d5"),
  n (scale "major" "2, 0, -3" |+ "d5"),
  (+ n "[1 0 _ 1] 0@3") $ n (scale "major" "1, -1, -3, -4" |+ "d5"),
  n (scale "major" "0, -3, -5" |+ "d5"),
  n (scale "major" "0, -3, -5" |+ "d5")
  ]
in do
  d1 "cp"
  d2 $ slow 4 $ fastcat notes # s "organTonewheel3, violin" # vowel "a"
  d2 $ ur 4 (segment (4 * 2) $ "p0 p1 p2 p3 p4 p5 p6@2") [
    ("p0", notes !! 0),
    ("p1", notes !! 1),
    ("p2", notes !! 2),
    ("p3", notes !! 3),
    ("p4", notes !! 4),
    ("p5", notes !! 5),
    ("p6", notes !! 6)
    ] [] # s "organTonewheel3, violin" # vowel "a"
