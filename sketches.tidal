do
  setcps (135/60/4)
  hush
  d1 $ "bd" # gain 2 # speed "1"
  d2 $ "~ cp"
  d3 $ n "0 7 ~ 0 . 8" |+ n "-5" # s "supermandolin" # vowel "o"
  d4 $ "hc(9, 16, 3)" # gain "[0.7!3 0.8] !"
  d5 $ "cp(5, 16)" # vowel "o" # gain 0.72
  d6 $ "cp(5, 16, 2)" # vowel "e" # gain 0.66



do
  setcps (135/60/4)
  hush
  d1 $ "<1(3, 8, 6) [1(3, 8, 6) ~] [1 1(3, 8, 6)]>" # s "lt" # gain 2
  d2 $ fast 4 $ s "<[hc hc*2] [hc hc ~ hc] hc*2 [~ hc]*2>" # gain "[0.9 0.7]"
  d3 $ "cp"
  d4 $ ""



do
  setcps (135/60/4)
  hush
  d1 $ "bd" # gain 2
  d2 $ "hc*4"
  d4 $ wrandcat [("t([5|6|7], 12, 1)", 0.5), ("t([11], 36)", 0.5), ("~ ~ . t t", 0.1)] # s "ht" # vowel "a"
  -- d5 $ fast 6 $ s "hc hc*2" # vowel "e" # gain 0.77
  -- d6 $ "cp(<5 6 8 6>,24,2)" # vowel "i"



do
  setcps (135/60/4)
  hush
  d1 $ "bd" # gain 2
  -- d1 $ fast 2 $ "1(5,8)" # s "bd" # gain 1.8
  d2 $ every 3 (const "hc([5|7],16,[2|4|5])") $ "hc(3,8)"
  d3 $ n "< [~ 5 5 ~ . 5 3] [~ 3 3 ~ . 3 1.5] [0 1.5 1.5 0 . 1.5 [0*2 ~]] [0, 7] [0, 7, [10 12]] [0, 7, 12] >" |- n 5 # s "supermandolin" # legato 2.2 # vowel "i" # gain 1.4
  d3 $ n "< [~ 5 5 ~ . 5 3] [~ 3 3 ~ . 3 1.5] [0 1.5 1.5 0 . 1.5 [0*2 ~]] [-24, -5, 0] >" |- n 5 # s "supermandolin" # legato "0.5 2.6@3" # vowel "i" # gain 1.5
  d4 $ slow "<2 2 1>" $ n "0 1 0 -2" |- n 5 # s "superpiano" # vowel "i" # legato 1
  -- d4 $ every 2 $ "cp(5, 8)"
  d5 $ s "sd"
  d6 $ degradeBy 0.2 $ n "7*8" |+ n "7,12" # s "superpiano" # vowel "i" # lpf 500
  -- d7 $ slow 2 $ n "<[0 12 10 8.5 7 5 3 1.5] [0 1.5 3 5 5 3 1.5 0]>" |- n (5 + 24) # s "supermandolin" # vowel "a" # gain 1.4 # legato 3



do
  setcps (135/60/5)
  d1 $ "bd" # gain 2
  d2 $ "hc*5" # vowel "o"
  d3 $ fast (5/2) $ "~ ~ ~ cp . ~ cp"
  d4 $ fast (5/4) $ "ht(10,16)" # vowel "o"



let myChord = [0, 3.86314, 7.01955, 12, 15.86314] -- Just intonation major.
in
d1 $ rolledBy (0.75 * rand^3 + 0.25) $ n (stack myChord) |+ n "df5" # s "supervibe" # room 0.5 # cps (wchoose [(0.6, 4), (0.4, 4), (0.2, 1)])



-- To use freq instead of n, make rand exponential using (hi - lo) * (rand^2) + lo
let
gainMax = 1.6
gainChange = 0.66
in do
d1 $ fast 1 $ stack [
  segment 12 $ n (12 * rand) # s "supervibe" # gain (gainMax - gainChange * rand),
  segment 12 $ n (12 * (fast 1.1 rand)) # s "supervibe" # gain (gainMax - gainChange * (fast 1.1 rand)),
  segment 12 $ n (12 * (fast 1.2 rand)) # s "supervibe" # gain (gainMax - gainChange * (fast 1.2 rand)),
  segment 12 $ n (24 * (fast 1.3 rand)) # s "supervibe" # gain (gainMax - gainChange * (fast 1.3 rand))
  ]
d2 $ segment 3 $ n (12 * rand) # octave 4 # s "fmBass" # gain 2


-- Hc every so often.
do
  d1 $ "cp"
  d2 $ fast 8 $ every (segment 1 $ irand 8) (const $ s "hc") $ "~"

-- Time-shifting a break.
do
  d1 $ "cp"
  d2 $ someCyclesBy 0.2 (const silence) $ (<~) (cycleChoose [0, 1/4, 2/4, 3/4]) $ striate 4 $ loopAt 1 "break:1" # cut 1

-- Improvisation starting-point.
do
  d1 $ "cp"
  d2 $ slice 8 "{0 1 2 3 4 5 6 7}%8" $ loopAt 1 "break:1" # cut 1

-- Improvisation starting-point.
let
normalBreak = chop 16 $ loopAt 1 "break:1" # cut 1
fastBreak = hurry 1.5 $ chop 16 $ loopAt 1 "break:1" # cut 1
mixedBreak = wrandcat [
    (fastBreak, 3),
    (normalBreak, 5)
  ]
in do
  d1 $ "cp"
  d2 $ mixedBreak

-- Starting point.
do
  d1 $ striate 2 $ loopAt 1 $ s "break:1" # cut 1 * speed "1 2 1 1"
  d2 $ "cp"

















