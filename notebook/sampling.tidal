-- Unit.  Changes the behavior of speed.  Accepts values of "r" (rate), "c" (cycles), or "s" (seconds).  The default is "r".
-- These two examples are equivalent.
d1 $ stack [
s "break:1" # speed 1 # unit "c",
s "cp"
]

d1 $ stack [
  loopAt 1 $ "break:1",
  s "cp"
]

-- Begin and End.  Play part of a sample.
-- Instead of using 'unit', 'begin' and 'end' by hand, use splice / slice / chop to cut a sound into bits, then set the length of the loop in cycles with loopAt.
-- These two examples are equivalent.
d1 $ stack [
  "break:1 !" # begin 0.75 # end 1,
  "cp"
]

d1 $ stack [
  slice 4 "3 ~ 3 ~" $ s "break:1",
  "cp"
]

-- Chop.  Cuts a sample into parts.
-- Lends itself to granular synthesis.
d1 $ stack [
  rev $ chop 4 $ loopAt 1 "break:1",
  "cp"
]

-- Striate.  Chop, but interlaces the cut-up bits.
d1 $ slow 4 $ striate 4 $ loopAt 1 $ s "break:1*4"

-- Striate with legato.
d1 $ slow 4 $ striate 4 $ loopAt 1 $ s "break:1*4" # legato 0.5

-- Slice.  Slice samples into bits, then pattern those bits by number.
-- Slice is for samples.  Bite is for patterns.
d1 $ stack [
  slice 8 "0 0 1 2 0 0 3 4 4" $ loopAt 1 $ s "break:1" # cut 1,
  "cp"
]

-- Randslice.  This example plays a random half of the sample each cycle.
d1 $ randslice 2 $ "break:1"

-- Splice.  Slice, but the slices are automatically pitched up or down to fit their slot, according to the number pattern.
d1 $ stack [
  splice 8 "0 1 2 0 3 4" $ loopAt 1 $ s "break:1",
  "cp"
]







{-

----------------------------------------------------------------------------------------------------------------

-- One-bar breaks.
-- 4, 6, 8, 15, 17, 27
-- Two-bar breaks that are cool.
-- 10, 13, 20, 25, 28, 31

-- bach: 134 bpm

-- cpu: 0-22
-- sax: 0-21

-}

-- These two examples are equivalent.
d1 $ slow 2 $ loopAt 1 $ s "break:1 break:8"
d1 $ loopAt 1 $ s "<break:1 break:8>"

-- For patterns with multiple samples, loopAt applies to each individual sample, not the pattern as a whole.
-- In this example, each sample stretches over two samples.
d1 $ loopAt 2 $ s "break:1 break:8"

-- So, loopAt is essentially cyclesPerSample, regardless of pattern structure.

-- Chop and Striate values also apply to each sample, not the pattern as a whole.
d1 $ stack [
  slow 2 $ loopAt 1 $ rev $ chop 2 $ s "break:1 break:8",
  "cp"
]

d1 $ stack [
  slow 2 $ loopAt 1 $ striate 2 $ s "break:1 break:8",
  "cp"
]

-- Speed affects only the sample speed.
-- Fast affects only the event speed.
-- Hurry affects both the sample speed and the event speed.
do
  d1 $ "cp"
  -- d2 $ every 2 (# speed (2/3)) $ chop 8 $ loopAt 1 "break:1" # cut 1
  -- d2 $ every 2 (fast (2/3)) $ chop 8 $ loopAt 1 "break:1" # cut 1
  d2 $ every 2 (hurry (2/3)) $ chop 8 $ loopAt 1 "break:1" # cut 1

-- Time-stretching can be done by first slicing the sample, then using either fast/slow or slice function.

-- Observe what happens when you move the speed control.
do
  d1 "cp"
  d2 $ striate 4 $ loopAt 1 $ s "break:1" # cut 1 * speed "1 2"  -- Gets structure from speed before striating.  Speed is baked into the structure.
  d2 $ striate 4 $ loopAt 1 $ s "break:1 !" # cut 1 # speed "1 2"  -- Same as above.
  d2 $ striate 4 $ (# speed "1 2") $ loopAt 1 $ s "break:1 !" # cut 1  -- Same as above.

do
  d1 "cp"
  d2 $ (* speed "1 2") $ striate 4 $ loopAt 1 $ s "break:1" # cut 1  -- Gets structure from base pattern, then striates.  Speed applied to each striated bit.
  d2 $ (# speed "1 2") $ striate 4 $ loopAt 1 $ s "break:1" # cut 1  -- Same as above.

-- What does not seem to work:
do
  d1 "cp"
  d2 $ (*| speed "1 2") $ striate 4 $ loopAt 1 $ s "break:1" # cut 1 -- Striate, then get structure from speed.
  d2 $ striate 4 $ loopAt 1 $ s "break:1" # cut 1 # speed "1 2" -- Gets structure from base pattern, but speed not applied because there's only one event each cycle.
  d2 $ chop 4 $ loopAt 1 $ s "break:1" # cut 1 # speed "1 2" -- Changing striate to chop makes this work.  Why?


-- Mask.  Silence parts of sample.
-- randomly drop 1/8 of cycle
do
  d1 $ mask (segment 8 $ wchoose [(True, 8), (False, 1)]) $ fast 2 $ chop 128 $ loopAt 1 $ s "break:1" # cut 1
  d2 "cp"

-- Unwrap.  Turns  Pattern[Pattern[x]] into Pattern[x].
do
  d1 "cp"
  d2 $ slice 8 (segment 8 $ unwrap $ wchoose [("<[0 1] [2 3]>", 3), ("<[4 5] [6 7]>", 1)]) $ loopAt 1 "break:4"

-- Random slices, but keep even slices on even beats and odd slices on odd beats.
let
m = 4
randSlice = irand $ div m 2
in do
  d1 "cp"
  d2 $ slice m (stitch (fast (m/2) $ "t f") (2 * randSlice) (2 * randSlice + 1)) $ loopAt 1 $ s "break:4"

-- Isolate segments of drum break:4.
-- 0 and 3 are same.  cymbal + bd on strong beats
-- 2 and 6 are same.  sd on strong beats
-- 1 and 4 are similar.  With 4, the accented offbeats are on sd, but with 1, they're on the bd
-- 5 and 7 are similar.  5 is more grounded, because at least bd marks the strong beats


-- Turn sample into palindrome.
do
  d1 "cp"
  d2 $ pickF "0 1" [id, rev] $ chop 4 $ loopAt 1 $ s "break:4" -- With chop 4, you get indices 0, 1, 1, 0.
  d2 $ pickF "0 1" [id, rev] $ chop 6 $ loopAt 1 $ s "break:4" -- On break:4 specifically, chop 6 works well.

-- Cool.
do
  d1 $ "cp" # gain 0.8
  d2 $ pickF "0 1" [id, fast 2] $ chop 2 $ loopAt 1 $ s "break:8" # cut 1 -- With chop 2, you get indices 0, 1, 0, 2
  d2 $ pickF "0 1" [id, (<~) 0.25 . fast 2] $ chop 2 $ loopAt 1 $ s "break:8" # cut 1 -- With chop 2, you get indices 0, 1, 2, 0
  d2 $ pickF "0 1" [id, fast 2] $ chop 4 $ loopAt 1 $ s "break:8" # cut 1 -- With chop 4, you get indices 0, 1, 2, 3, 0, 2, 4, 6
  d2 $ pickF "0 1" [id, (<~) 0.125 . fast 2] $ chop 4 $ loopAt 1 $ s "break:8" # cut 1 -- With chop 4, you get indices 0, 1, 2, 3, 2, 4, 6, 0



-- Faster tempo:
-- fast 1.X, # cut 1
do
  d1 $ "cp" # gain 0.8
  d2 $ fast 1.5 $ chop (16 * 24) $ loopAt 24 $ s "bach" # cut 1

-- Lower key:
-- # cut 1 # speed 0.X
do
  d1 $ "cp" # gain 0.8
  d2 $ chop (16 * 24) $ loopAt 24 $ s "bach" # cut 1 # speed 0.75

-- Slower tempo (without lowering key) and higher key (without slowing tempo) don't seem possible.
-- Slow it down in Ableton first.



