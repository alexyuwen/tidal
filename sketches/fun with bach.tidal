-- Repeat each measure in two keys.
let
slicesTotal = 8 * 24
in do
  setcps (134/60/4)
  d1 $ "cp" # gain 0.8
  d2 $ slice slicesTotal (8 * (slow 48 $ run 24) + run 8) $ loopAt 24 $ s "bach" # speed "[1 0.944 0.944 1]*6"



-- Transpose by half step each measure.
let
slicesTotal = 8 * 24
speeds = [2 ** (-i / 12) | i <- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]]
in do
  setcps (134/60/4)
  d1 $ "cp" # gain 0.8
  -- Down a half step each measure.  These two examples are equivalent.
  d2 $ slice slicesTotal (8 * (slow 24 $ run 24) + (run 8)) $ loopAt 24 $ s "bach" # speed (fit 0 speeds (run 24 |% 5)) # cut 1
  d2 $ slice slicesTotal (8 * (slow 24 $ run 24) + (run 8)) $ loopAt 24 $ s "bach" # speed (select ((/11) <$> (run 24 |% 12)) speeds) # cut 1
  -- Up a half step each measure.  These two examples are equivalent.
  d2 $ slice slicesTotal (8 * (slow 24 $ run 24) + (run 8)) $ loopAt 24 $ s "bach" # speed (rev $ fit 0 speeds (1 + run 24 |% 5)) # cut 1

resetCycles

-- Shuffling within each measure.
let
slicesTotal = 8 * 24
in do
  setcps (134/60/4)
  d1 $ "cp" # gain 0.8
  d2 $ slice slicesTotal (8 * (slow 24 $ run 24) + (shuffle 4 $ run 8)) $ loopAt 24 $ s "bach"



-- Transposing a diminished arpeggio.
let
slicesTotal = 8 * 24
in do
  setcps (134/60/4)
  d1 $ "cp" # gain 0.8
  d2 $ slice slicesTotal (8 + (fast 2 $ run 4)) $ loopAt 24 $ s "bach" # speed (segment 48 $ range 0.6 1 rand) # cut 1



-- Play each measure forward then backward.
let
slicesTotal = 8 * 24
in do
  setcps (134/60/4)
  d1 $ "cp" # gain 0.8
  d2 $ every' 2 1 rev $ slice (2 * 24) (2 * (slow 48 $ run 24) + (run 2)) $ loopAt 24 $ s "bach"



-- Ply 2.
let
slicesTotal = 8 * 24
in do
  setcps (134/60/4)
  d1 $ "cp" # gain 0.8
  d2 $ ply 2 $ slice slicesTotal (8 * (slow 24 $ run 24) + (run 8)) $ loopAt 24 $ s "bach" # cut 1



-- Random measure each cycle.
let
slicesTotal = 8 * 24
in do
  setcps (134/60/4)
  d1 $ "cp" # gain 0.8
  d2 $ slice slicesTotal (8 * (segment 1 $ irand 24) + (run 8)) $ loopAt 24 $ s "bach"



-- Measures 0, 0..1, 0..2, 0..4, 0..8, 0..16, 0..23
let
slicesTotal = 8 * 24
x = (concatMap (\n -> [0 .. 2^n - 1]) [0..4]) ++ [0 .. 23]
in do
  setcps (134/60/4)
  d1 $ "cp" # gain 0.8
  d2 $ slice slicesTotal (8 * (cat $ map pure x) + (run 8)) $ loopAt 24 $ s "bach" -- Without map pure, you would get the Enum error.



-- Apply functions using PickF.
let
slicesTotal = 8 * 24
sample = slice slicesTotal (8 * (slow 24 $ run 24) + (run 8)) $ loopAt 24 $ s "bach"
in do
  setcps (134/60/4)
  d1 $ "cp" # gain 0.8
  d2 $ pickF (slow 2 $ "0 0 0 [1 0 0 0]") [id, const silence] $ sample



-- More PickF, but using both chunks and slices.
let
chunksTotal = 2 * 24
sample = slice chunksTotal (2 * (slow 24 $ run 24) + (run 2)) $ loopAt 24 $ s "bach"
in do
  setcps (134/60/4)
  d1 $ "cp" # gain 0.8
  -- Chunk into 2 per measure so that ply applies to chunk.  Then, chop into 8 so that cut applies to each note.
  d2 $ (chop 8 $ pickF (segment 1 $ irand 2) [id, (fast 2 . ply 2 . slow 2)] $ sample) # cut 1
  -- Try using spreadf instead of pickF.
  -- d2 $ spread ($) [id, (fast 2 . ply 2 . slow 2)] $ sample # cut 1



resetCycles




-- Standing on the dominant.
let
chunksTotal = 2 * 24
dominantChunks = [2, 3, 10, 13, 14, 17, 27, 31, 38, 39, 40, 42, 43, 46, 47]
in do
  setcps (134 / 60 / 4)
  d1 $ "cp" # gain 0.7
  -- segment 4, but each segment lasts half a cycle, so segments overlap
  d2 $ slice chunksTotal (segment 4 $ choose dominantChunks) $ s "bach" # cut 1



-- Chord from stacking multiple slices.
let
slicesTotal = 8 * 24
in do
  setcps (134 / 60 / 4)
  d1 $ "cp" # gain 0
  d2 $ bite 8 "[0, 1, 5, 6, 7]*8" $ loopFirst $ chop slicesTotal $ loopAt 24 $ s "bach"



-- Each chunk is the previous chunk shifted some notes forward
let
slicesTotal = 8 * 24
in do
  d1 $ "cp" # gain 0.8
  d2 $ slice slicesTotal (fast 2 $ (slow slicesTotal $ run slicesTotal) + run 4) $ s "bach" -- 1: [0 1 2 3] [1 2 3 4] [2 3 4 5]
  d2 $ slice slicesTotal (fast 2 $ (slow (slicesTotal / 2) $ listToPat [0, 2 .. slicesTotal - 2]) + run 4) $ s "bach" -- 2: [0 1 2 3] [2 3 4 5] [4 5 6 7]




-- Repeat every chunk, but the chunk is either [0 1 2 3] or [4 1 2 3]
let
slicesTotal = 8 * 24
in do
  d1 $ "cp" # gain 0.7
  d2 $ slice slicesTotal ((fit 1 [0, 4 .. slicesTotal - 4] "0") + ((<~) 2 $ scramble 2 "0 1 2 3 . 4 1 2 3")) $ s "bach"



-- Play only the first half of each chunk: [0 1 4 5] [8 9 12 13]
let
slicesTotal = 8 * 24
in do
  d1 $ "cp" # gain 0.8
  d2 $ slice slicesTotal (8 * (slow 12 $ run 24) + "[0 1 4 5]*2") $ s "bach"



-- Loop the first measure. Transpose it and make it a polymeter, with those two changes being coupled.
let
slicesTotal = 8 * 24
speeds = [2 ** (-i / 12) | i <- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]]
randIndex = segment 1 $ irand 3
in do
  d1 $ "cp" # gain 0.8
  d2 $ slice slicesTotal (fast (bite 3 randIndex "1 1.75 1.25") $ run 8) $ s "bach" # cut 1 # speed (bite 12 (2 * randIndex) $ listToPat speeds)






resetCycles





