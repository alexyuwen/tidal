-- Const.
d1
$ every 6 (const("hc(6,8)*2"))
$ every 5 (const $ "hc!13")
$ every 2 (const $ "hc")
$ "hc(5, 7)"

-- Bite.  Slice each cycle into a given number of equal sized bits, then pattern those bits by number.
-- The sliced bits will be squeezed or contracted to fit.
-- Slice is for samples.  Bite is for patterns (over one cycle).
d1 $ bite 4 "0 1 1 2 3" "<[bd cp [~ bd] cp] [sd hc [~ sd] hc]>"

-- Scale.
d1 $ n (scale "minor" $ run 8) # s "supermandolin"

-- Scale in different key
d1 $ n (scale "minor" $ run 8) |+ n "d" # s "supermandolin"

-- Ply.  Repeats each event the given number of times.
d1 $ ply 2 $ n (scale "minor" "0 2 1 4") # s "supersaw" # legato 0.1 # lpf 800

-- Arp.
-- up down; n;                      2  3  4  5  6
-- updown downup; 2n - 2;           2  4  6  8  10
-- pinkyup thumbup; 2n - 2;
-- disconverge; 2n - 1;             3  5  7  9  11
-- pinkyupdown thumbupdown; 4n - 6; 2  6  10 14 18

-- These two examples are equivalent.
d1 $ arp "up" $ n "<c'maj bf'min>" |+ n "<0 -12>" # s "supermandolin"
d1 $ arp "up" $ n "<c'maj bf'min>" # octave "<5 4>" # s "supermandolin"

-- Arpg.  Same as arp "up".
d1 $ arpg $ n "c'min" # s "supermandolin"

-- More than one arp per chord.
d1 $ arp "up down" $ ply 2 $ n "<c'maj'4 bf'min'4>" # octave "<5 4>" # s "supermandolin"

-- Make new arpeggio pattern from sub-pattern of existing one.
-- There is a big limitation with this approach.  The number of notes differs between arpeggiation modes and cannot be inferred.  Bite must know beforehand.
d1 $ bite 8 (run 8 |% 5) $ arp "updown" $ n "c'min'5" # s "supermandolin"

-- Custom arpeggio pattern.
-- This almost solves the limitation with the previous example.  Because it still relies on bite, it is difficult to pattern the chords.
do
  d1 "cp"
  d2 $ bite 5 "0 1 2 3 4 0 1 2" $ arpg $ n "c'min'5" # s "supermandolin"

-- TimeCat.  Fastcat, but with proportioning of patterns.
-- Useful for combining patterns while maintaining constant subdivision.
-- Equally useful for combining patterns at different subdivisions.
-- Note that TimeCat accepts Time, not Pattern.
do
  d1 "cp"
  d2 $ bite 5 (timeCat [
    (5, run 5),
    (4, run 4)
      ]) $ arpg $ n "c'min'5" # s "violin"

-- Custom scale.  These two examples are equivalent.
d1 $ slow 2 $ n (toScale [0,1.5,3,5,7,8.5,10] "0..7") # s "supervibe"

let scale = getScale (scaleTable ++ [("microtonal", [0,1.5,3,5,7,8.5,10])])
d1 $ slow 2 $ n (scale "microtonal" "0..7") # s "supervibe"

-- Custom chord.
let myChord = "[0, 3.5, 7]"
d1 $ rolled $ n myChord |+ n "<c5 bf4>" # s "supervibe"

-- Ur.  Pattern of patterns, over a given number of cycles.  It takes four parameters:
-- 1. how many cycles the loop will take
-- 2. a pattern giving the structure of the composition
-- 3. a lookup table for named patterns to feed into that structure
-- 4. a second lookup table for named transformations/fx
d1 $ ur 2 "p1 p2 . p1:e1 p2:e1"
[
("p1", s "bd"),
("p2", s "cp")
]
[
("e1", (# squiz 3))
]

-- Fit.  Plays from a list according to the sequence of indexes, but starts from a different index each cycle.
d1 $ n (fit 1 [0, 1, 4, 7] "0 1 2 3 0") # s "supervibe"

-- Random pitches.
d1 $ segment 16 $ n (10 * rand) # s "supervibe" # legato 0.5

-- Random pitches in a scale.
d1 $ segment 8 $ n (scale "minor" $ irand 8) # s "supervibe" # legato 0.5

-- Math on rand.
d1 $ rolledBy (0.75 * rand^2 + 0.25) $ n "df'maj'5" # s "supervibe" # room 0.5 -- For x between 0 and 1, y is between 0.25 and 1, favoring the bottom

-- Decoupling multiple rands, because rand is a deterministic function of time.
-- In the first example, all the high pitches are in the right speaker.  In the second example, pitch is decoupled from panning.
d1 $ segment 16 $ n (24 * rand) # s "supervibe" # pan rand
d1 $ segment 16 $ n (24 * rand) # s "supervibe" # pan (slow 1.1 rand)

-- Randomly drop events with question mark.
-- Note that ? after [] will randomly remove each event inside [] individually.
d1 $ fast 2 $ stack [
"bd?0.2 bd" # squiz 3 # gain 2,
"~ ~ ~ cp . ~ cp?0.2"
]

-- Randomly drop events with degrade and degradeBy
d1 $ degradeBy 0.2 $ fast 4 $ "1 . 1 1" # s "glockenspiel:-24" # legato 0.8

-- Sometimes.
d1 $ "1*16" # (sometimes (|+ n 12) $ n (range 0 6 rand)) # s "supervibe"

-- SometimesBy.
d1 $ "1*16" # (sometimesBy 0.2 (|+ n 12) $ n (range 0 6 rand)) # s "supervibe" -- Applies |+ n 12 on average 20/100 cycles.

-- SomeCycles.  Sometimes, but applies a function to random cycles instead of random events.
d2 $ someCycles (fast 2) $ "glockenspiel:-24(5,8)"

-- SomeCyclesBy.
d2 $ someCyclesBy 0.33 (fast 2) $ "glockenspiel:-24(5,8)" -- Applies fast 2 on average 33/100 cycles.

-- Scramble.  Divides the pattern into parts, then randomly selects from the parts.  Sampling with replacement.
d2 $ scramble 2 $ stack [
 "1 1*2 . 1 1 ~ 1" # s "hc",
 "1 . 1 1" # s "bd" # squiz 2 # gain 2
]

-- Shuffle.  Divides the pattern into parts, then permutes the parts, picking one of each per cycle.  Sampling without replacement.
-- These two examples are equivalent.
do
  d1 $ "cp"
  d2 $ shuffle 4 $ "1 . 1@3 1 . 1 1 . ~" # s "bd" # squiz 2 # gain 1.5
  d2 $ shuffle 4 $ fastcat ["1", "1@3 1", "1 1", "~"] # s "bd" # squiz 2 # gain 1.5

-- All the chords.
import Sound.Tidal.Chords
chordList

-- Choose. By itself, it produces a continuous stream, with no structure.
-- With choose, the parameters to choose from are a list of values, not patterns -- the pattern equivalent is Randcat.
-- As such, you can't normally use mininotation there.  A supposed workaround is innerJoin but that isn't working.
d1 $ rolledBy (choose [0.25, 0.5, 0.7]) $ n "df'maj'5" # s "supervibe" # room 0.5

-- These two examples are identical.
let
scramblePat = "1 2 3 0 . 1 2 1 0 . 1 0 1 2 . 3 2 1 0"
scrambleList = ["1 2 3 0", "1 2 1 0", "1 0 1 2", "3 2 1 0"]
in do
  d1 $ "cp"
  d2 $ n (bite 4 (scramble 4 scramblePat) $ (scale "minor" "-3 0 1 2")) # s "violin"
  d2 $ fast 4 $ n (bite 4 (unwrap $ segment 1 $ choose scrambleList) $ (scale "minor" "-3 0 1 2")) # s "violin"

-- Segment + choose.
d1 $ segment 16 $ n (6 * rand) |+ n (segment 3 $ choose [0, 10, 20]) # s "supervibe" # legato 0.5

-- Wchoose.
d1 $ segment 16 $ n (scale "minor" (wchoose [(0, 6), (2, 2), (4, 2), (7, 2)])) # s "supervibe"

-- CycleChoose.  Choose, but once per cycle.
d1 $ n "0 0 1 1 2 2 1 1" # s "supersaw" # lpf (cycleChoose [400, 1200, 3600])

-- ChooseBy.  Choose, but instead of selecting elements of the list randomly, it uses the given pattern to select elements.
-- At first glance, this functions seems unwieldy to me.
d1 $ n (chooseBy "0 0.2 0.4 0.6 0.8" [0..3]) # s "supervibe" -- 0 <= x < 0.25 maps to 0, 0.25 <= x < 0.5 maps to 1, etc.  x > 1 wraps around: only the decimal matters.

-- ChooseBy, accommodate arbitrary number of patterns.
-- Again, unwieldy.  Use Select instead.
do
  d1 "cp"
  d2 $ unwrap (chooseBy (listToPat $ map (/2) [0, 0, 0, 0, 1, 0, 0, 0]) [
    bite 5 "0 1 2 3 4 2 3 4" $ arpg $ n "c'min'5",
    fast 8 $ n (scale "minor" "2 1 . 0") # octave 6
    ]) # s "violin"

-- Select.  Choose between a list of patterns using a pattern of floats (from 0 to 1).
-- With three or more patterns, just use integer indices divided by (n - 1) where n is number of patterns.
let
pat1 = bite 5 "0 1 2 3 4 2 3 4" $ arpg $ n "c'min'5"
pat2 = fast 8 $ n (scale "minor" "2 1 . 0") # octave 6
in do
  d1 "cp"
  d2 $ select (listToPat $ map (/1) [0, 0, 0, 0, 1, 0, 0, 0]) [pat1, pat2] # s "violin"  -- If there were three patterns, then map (/2).
  d2 $ select ((/1) <$> "0 0 0 0 1 0 0 0") [pat1, pat2] # s "violin" -- Equivalent to above, but more concise.

-- Cat.
d1 $ cat ["hc(3,8)", "hc(9,16,7)"]

-- Randcat.
d1 $ randcat ["sd", "sd(3,8)", "sd(9,16)"]

-- Wrandcat.
d1 $ wrandcat [
("sd", 1),
("sd sd", 2),
("sd(3,8)", 3)
]

-- SeqPLoop.
d1 $ seqPLoop [
(0, 2, "bd bd" # gain 2),
(2, 4, "bd(3,8)" # gain 2),
(4, 6, "bd(5,8)" # gain 2),
(1, 3, euclidInv 6 16 "hc"),
(3.5, 5, "hc!8")
]

-- Time shifting using <~ and ~>.  The arrow direction indicates which way the pattern shifts.
d1 $ every 2 ((1/8) <~) $ n (scale "minor" "0 3 1 2") # s "supervibe"

-- Time shifting by random amount.
let
tetraChord = fastcat [
  n $ scale "minor" "0 1 2 4",
  n $ scale "minor" "0 1 2 4" + 12,
  n $ scale "minor" "0 1 2 4" + 24,
  n $ scale "minor" "0 1 2 _" + 36
  ]
pat = tetraChord # s "supervibe" # legato 8 # lpf 999 # vowel "o"
in do
  d1 "cp"
  d2 $ (<~) ((<~) 1 $ segment 0.5 $ rand) $ whenmod 2 1 (const silence) $ pat -- (<~) 1 makes sure random value isn't generated in middle of pattern

-- Ratio shorthand (mini notation) using %.
-- These three examples are equivalent.
d1 $ "supervibe:0*8" # cps ("<8%10 16%10>")
d1 $ "supervibe:0*8" # cps (cat [0.8, 1.6]) -- Here, cat is used to cycle through values each cycle.

-- Freq.
d1 $ segment 16 $ freq (range 200 240 rand) |* freq "1 2" # s "supervibe"

-- Polymeter using curly braces.  The base rhythm comes from the left (the first pattern).
d1 $ n "{0 1 -2, 7 12}" # s "supervibe"

-- Polyrhythm.
-- These two examples are identical.
d1 $ n "{0 1 -2}%8" # s "supervibe"
d1 $ n "{~!8, 0 1 -2}" # s "supervibe"  -- Note the exclamation mark.  Asterisk will not work.

-- Speeding up/down oscillators.
d1 $ segment 16 $ n (fast 1.5 $ range 0 20 sine) # s "supersaw" # lpf 999 -- Notice that every three waves (two cycles), the pitches repeat.

-- Euclidean offset using time shifting operator.
-- Here are three different options to avoid having <~ next to $.
d1 $ ((1/8) <~) $ euclid 3 8 $ s "cp"
d1 $ (1/8) <~ (euclid 3 8 $ s "cp")
d1 $ (<~) (1/8) $ (euclid 3 8 $ s "cp") -- Wrapping <~ in parentheses turns it into a normal function with arguments on the right-hand side

-- Random Euclidean offset.
-- These three examples are equivalent.
let fractions = [n / 8 | n <- [0 .. 7]] -- List comprehension.
in do
  d1 $ "hc"
  d2 $ (<~) (cycleChoose fractions) $ (euclid 3 8 $ s "cp")
  d2 $ (<~) (cycleChoose [0, 1/8 .. 7/8]) $ (euclid 3 8 $ s "cp")
  d2 $ (<~) ((segment 1 $ irand 8) / 8) $ euclid 3 8 $ s "cp"

-- EuclidInv and EuclidFull.
-- These two examples are equivalent.
d1 $ stack [(euclid 6 16 "bd" # gain 2), (euclidInv 6 16 "hc")]
d1 $ euclidFull 6 16 ("bd" # gain 2) "hc"

-- Perlin.  Generates a new random value to move to every cycle, but moves smoothly between each value.
d1 $ segment 16 $ n (fast 4 $ range 0 20 perlin) # s "supersaw" # lpf 999

-- Pattern composition using dot.
d1 $ every 2 ((<~) 0.125 . rev) $ n (scale "minor" "0 1 2 1") # s "supervibe"

-- MarkovPat.  Its three arguments are: sequence length, start index, and matrix.
-- Every cycle starts on the start index.
-- Sequence length of n means 1/n of a cycle.  Only integer sequence length allowed, so each pattern cannot exceed one cycle.
-- MarkovPat is broken.  It does not follow the probability matrix.
do
  d1 $ "hc"
  d2 $ s $ fmap (["bd", "sd", "clap"]!!)  -- !! takes a list on the left and an index on the right, then returns the item at that index.
       $ markovPat 4 0 [
           [0, 1, 0],
           [0.15, 0.1, 0.8],
           [0.5, 0.3, 0.4]
         ]

-- FastGap.  Rather than it playing multiple times as fast would, it instead leaves a gap in the remaining space of the cycle.
d1 $ fastGap (segment 0.5 $ rand / 2 + 1) $ segment 10 $ n (12 * rand) # s "supervibe" # gain 1.4

-- Compress.  Squeezes the pattern into a time span.
d2 $ compress (1/4, 1) $ s "hc(6,8)"

-- Zoom.  Plays a portion of a pattern over the time period of the original pattern.
d2 $ every 3 (zoom (0.25, 1)) $ s "hc(9,12)"

-- Within.  Applies a function to only a part of a pattern.
-- Note that Within accepts (Time, Time), not (Pattern, Pattern).
do
  d1 "cp"
  d2 $ within (0, 0.1) (fast 2) $ s "hc*8"

-- Stretch.  Zooms in on a pattern to avoid silences at the start or end.
d1 $ note (stretch "~ <0 ~> 1 5 8*4 ~") # s "superpiano"

-- Superimpose.  Applies a function to a pattern, superimposed on the original pattern.
d1 $ superimpose (|+ n "12") $ n "0" # s "supervibe"

-- Off.  Superimpose, but with a time offset for the transformed pattern.
d1 $ off 0.1 (|+ n "12") $ n "0" # s "supervibe"

-- Press.  delays a sound for half the time in its slot.  Turns every instance of a into [~ a].
-- Every beat becomes an offbeat, so the overall effect is to syncopate a pattern.
d2 $ press $ slow 2 $ "bd cp [bd bd] cp"

-- PressBy.  Press, but with a variable time offset.
d2 $ slow 2 $ pressBy "<0 0.5>" $ "bd cp [bd bd] cp"

-- Rev.  Reverses a pattern.
d2 $ every 3 rev $ "bd cp [~ bd] cp"

-- Jux.  Applies a function to a pattern, but only in the right-hand channel.
d1 $ jux (+| n "-12, 12") $ segment "9|12" $ n (12 * rand) # s "supervibe"

-- JuxBy.  Jux, but instead of panned at a hard 0 and 1, specify how much to pan.
-- JuxBy 1 = Jux = pan at 0 and 1
-- JuxBy 0.5 = pan at 0.25 and 0.75
-- JuxBy 0 = pan at 0.5 and 0.5
d1 $ juxBy 0.5 (+| n "-12, 12") $ segment "9|12" $ n (12 * rand) # s "supervibe"

-- SwingBy.  The function swingBy x n breaks each cycle into n slices, then delays events in the second half of each slice by x.
do
  d1 "cp"
  d2 $ swingBy (1/3) 4 $ sound "hh*8"

-- Swing.  Alias for SwingBy (1/3).
-- These two examples are equivalent.
do
  d1 "cp"
  d2 $ swingBy (1/3) 4 $ sound "hh*8"
  d2 $ swing 4 $ sound "hh*8"

-- Inside.  Applies function "inside" a cycle.  Inside n f is equivalent to (fast n . f . slow n)
-- These two examples are equivalent.
do
  d1 "cp"
  d2 $ inside 2 (fastGap 1.25) $ chop 512 $ loopAt 1 $ s "break:1" # cut 1
  d2 $ (fast 2 . fastGap 1.25 . slow 2) $ chop 512 $ loopAt 1 $ s "break:1" # cut 1

-- Outside.  Applies function "outside" a cycle.  Inside n f is equivalent to (slow n . f . fast n)
-- These two examples are equivalent.
do
  d1 "cp"
  d2 $ outside 2 rev $ n (scale "minor" $ slow 2 $ run 8) # s "supervibe"
  d2 $ (slow 2 . rev . fast 2) $ n (scale "minor" $ slow 2 $ run 8) # s "supervibe"

-- Echo.  Specify the number or echoes, the time between echoes in cycles, and the volume dropoff per echo.
d2 $ echo 3 0.2 0.7 $ sound "cp"
d2 $ echo 3 (-0.2) 0.7 $ sound "cp" -- Reverse echo.  Echo before the note instead of after.

-- EchoWith.  Echo, but any functions can be applied to echoes, not just volume.
-- Also, unlike Echo, the first argument of EchoWith includes the base event.
-- Note: A function like "|+ n ..." piles the function on top for each echo, which is probably unintended.
d1 $ echoWith 4 (1/8) (# octave 2) $ sound "supervibe" # n "0"

-- FoldEvery.  Essentially, chains multiple every functions together.
-- If a particular cycle is the start of more than one of the given cycle periods, then the function is applied more than once.
-- These three examples are equivalent.
d1 $ foldEvery [2,3] (ply 2) $ n (scale "minor" "0 2 1 4") # s "supervibe"
d1 $ every 2 (ply 2) $ every 3 (ply 2) $ n (scale "minor" "0 2 1 4") # s "supervibe"
d1 $ (every 2 (ply 2) . every 3 (ply 2)) $ n (scale "minor" "0 2 1 4") # s "supervibe"

-- Fix. Applies function to matching events in a pattern of controls. Fix is contrast where the false-branching function is set to the identity id.
d1 $ fix (# octave 6) (n (scale "minor" "[0, 4, 7]")) $ n (scale "minor" "0..7") # s "supervibe"

-- Unfix.  Fix, but applies function only when the testing pattern is not a match.
d1 $ unfix (# octave 6) (n (scale "minor" "[0, 4, 7]")) $ n (scale "minor" "0..7") # s "supervibe"

-- Contrast.  Basically an if-else-statement over patterns.  For contrast t f p, think of t as the true-branch, f as the false branch, and p as the test.
-- These two examples are equivalent.
d1 $ contrast (# octave 6) (# legato 0.3) (n (scale "minor" "[0, 4, 7]")) $ n (scale "minor" "0..7") # s "supervibe"
d1 $ contrastBy (==) (# octave 6) (# legato 0.3) (n (scale "minor" "[0, 4, 7]")) $ n (scale "minor" "0..7") # s "supervibe"

-- ContrastBy.  A more general version of contrast that takes an abritrary boolean function that is used to compare the control patterns.
d1 $ contrastBy (>=) (# octave 6) (# legato 0.3) (n (scale "minor" 2)) $ n (scale "minor" "0..7") # s "supervibe" -- Applies true-branch if 2 >= note

-- Palindrome.  Applies rev to a pattern every other cycle, so that the pattern alternates between forwards and backwards.
-- These two examples are equivalent.
d1 $ palindrome $ n (scale "minor" "0 1 2 1") # s "supervibe"
d1 $ every 2 rev $ n (scale "minor" "0 1 2 1") # s "supervibe"

-- Trunc.  Truncates a pattern so that only a fraction of the pattern is played.
do
  d1 "hc"
  d2 $ trunc "<0.25 1 0.5 1>" $ sound "sd cp [~ sn] cp"

-- Linger.  Trunc, but repeats the truncated part to fill the remainder of the cycle.
-- Doesn't work for uneven denominators.  Turns into polymeter rather than resetting each cycle.
do
  d1 "hc"
  d2 $ linger "<0.25 1 0.5 1>" $ sound "sd cp [~ sn] cp"

-- Chunk.  Divides a pattern into parts, then applies the function to each part in turn (one part per cycle).
d1 $ chunk 4 (# gain 1.5) $ sound "sd . cp cp"

-- Chunk'.  Chunk, but cycles through the parts in the reverse direction.
d1 $ chunk' 4 (# gain 1.5) $ sound "sd . cp cp"

-- LoopFirst.  Loops only the first cycle of a pattern.
d1 $ someCyclesBy 0.33 loopFirst $ s "<hc(3,8) [hc(3,8)*3]>" -- Combines with someCyclesBy to interject the first cycle randomly

-- Amp.  Whereas gain is exponential, amp is linear.
d1 $ "hc*18" # amp (1 - saw)

-- Accelerate.  Speeds up (or slows down) samples while they play.
-- Accelerate 0 does nothing.  Negative values decelerate.
d1 $ s "sax:0" # accelerate 1 # cut 1

-- Speed.  Changes the speed of sample playback.  Both sample duration and pitch will be modified.
-- Negative values play the sample backwards.
d1 $ s "sax:0" # speed "<1 2 3 4>" # cut 1

-- Mask.  Uses a binary pattern to mask another pattern.
-- Note that Mask only masks events.  Sustained sounds will not be masked, even with cut 1.
d1 $ stack [
  "cp",
  mask "1 . [0 1] 1" $ segment 16 $ n (range 0 12 rand) # s "supervibe"
]

-- Stitch.
-- Stitch gets the structure from the binary pattern, whereas Sew gets it from the two source patterns.
do
  d1 "cp"
  d2 $ stitch "t(3,8)" (n 0 # s "supervibe") (s "snare:4")

-- Sew.  Uses a binary pattern to switch between two other patterns.
-- Stitch gets the structure from the binary pattern, whereas Sew gets it from the two source patterns.
do
  d1 "cp"
  d2 $ sew "t(3,8)" (segment 16 $ n 0 # s "supervibe") ("sd*8")

-- Generating a tone with segment.
d1 $ segment 90 $ n 0 # octave 1 # s "acidOto3091" # gain 2

-- Whenmod.  (Whenmod a n ...) applies function to pattern when current loop number mod a >= n.
d2 $ whenmod 5 3 (fast 2) $ chop 8 $ loopAt 1 $ "break:1" # cut 1 -- Normal on loops 0, 1, 2, fast on loops 3, 4

-- Unwrap.  Turns  Pattern[Pattern[x]] into Pattern[x].
-- Try to use Select instead.
do
  d1 "cp"
  d2 $ segment 8 $ n (unwrap $ wchoose [("0 1", 3), ("7 8", 1)]) # s "supervibe"

-- Spread.  Spreads a function across several values.  Useful if the function doesn't accept pattern input.
-- These two examples are equivalent.
d1 $ spread fast[2,3] $ s "[hc . hc hc]"  -- This example isn't useful, because fast does accept pattern input.
d1 $ fast "<2 3>" $ s "[hc . hc hc]"

-- Spreadf.  Shorthand for Spread ($), which lets you put different functions as the list of values.
-- These two examples are equivalent.
d1 $ spreadf [fast 1, fast 2, fast 3, fast 4] $ s "[hc . hc hc]"
d1 $ spread ($) [fast 1, fast 2, fast 3, fast 4] $ s "[hc . hc hc]"

-- SpreadChoose.  Spread, but select values randomly.
-- SpreadR is alias.
d1 $ spreadChoose fast[1,2,3,4] $ s "[hc . hc hc]"
d1 $ spreadr fast[1,2,3,4] $ s "[hc . hc hc]"

-- Haskell function definition.
let
baseNotes = "0 4 2 1"
notes x = fast 8 $ fastcat (map (+x) [2, 1, 2, 1]) -- Ornament.
in do
  d1 "hc"
  d2 $ n (scale "minor" $ sew "1 1 1 [1 0]" baseNotes $ notes 0) # octave 4 # s "organTonewheel3" -- Insert ornament with sew.

-- Squeeze.  Squeezes patterns into each cycle.  Takes a pattern of integers and a list of patterns.
-- Squeeze plays all patterns entirely in each cycle, whereas Select plays only portions of patterns each cycle.
-- These two examples are equivalent.
do
  d1 "cp"
  d2 $ n (squeeze "0 . 1 1" [listToPat [0, 7], listToPat [2, 3]]) # s "organTonewheel3"
  d2 $ n (squeeze "0 . 1 1" [fastcat [0, 7], fastcat [2, 3]]) # s "organTonewheel3"

-- <$>.  Infix synonym for fmap.  fmap f x === f <$> x
d1 $ bite 8 (segment 8 $ floor <$> range 0 8 perlin) $ arpg $ n "c'min'8" # s "violin"

-- Iter.  Divides pattern into subdivisions, and increments the starting subdivision each cycle.  Wraps around to the first subdivision after the last.
do
  d1 "cp"
  d2 $ iter 4 $ n (scale "minor" "0 1 . 2 . 2 1 . 0") # s "violin"

-- Iter'.  Iter, but in the other direction.  Decrements the starting subdivision each cycle.  Wraps around to the last subdivision after the first.
-- I think Iter' is more cohesive than Iter because the last segment of the last variation is always immediately repeated.
do
  d1 "cp"
  d2 $ iter' 4 $ n (scale "minor" "0 1 . 2 . 2 1 . 0") # s "violin"

-- Rot.  Rotates the values (not rests) in a pattern while preserving structure.  Increments starting position by rotation amount.
do
  d1 "cp"
  d2 $ rot 1 $ n (scale "minor" "0 4 ~ [2 4]") # s "violin"

-- Sew vs Select for switching between two patterns.
-- I prefer select in all cases.
let
scramblePat = "1 2 3 0 . 1 2 1 0 . 1 0 1 2 . 3 2 1 0"
arpPat = n (bite 8 (scramble 4 scramblePat) $ arpg $ "c4'min'8'i2") # s "violin"
scalePat = n (bite 4 (scramble 4 scramblePat) $ (scale "minor" "-3 0 1 2")) # s "violin" -- Pitch set.  Arpeggio generalized.
in do
  d1 $ "cp"
  d2 $ sew "t t t f" arpPat scalePat -- Non-random.
  d2 $ select "0 0 0 1" [arpPat, scalePat]
  d2 $ sew (segment 2 $ choose [False, True]) arpPat scalePat -- Random.
  d2 $ select (segment 2 $ irand 2) [arpPat, scalePat]
  d2 $ sew (segment 2 $ wchoose [(True, 1), (False, 3)]) arpPat scalePat -- Random, with weighted probabilities.
  d2 $ select (segment 2 $ wchoose [(0, 1), (1, 3)]) [arpPat, scalePat]
  d2 $ sew (segment 2 $ "t|f|f|f") arpPat scalePat -- Random, with weighted probabilities, with mininotation.
  d2 $ select (segment 2 $ "0|1|1|1") [arpPat, scalePat]

-- While.  Applies function based on boolean structure.
do
  d1 "cp"
  d2 $ while "f(3,8)" (ply 2) $ n (scale "minor" $ run 8) # s "violin"

-- Smooth.  Takes a pattern of numbers and linearly goes from one to the next, passing through all of them.  Goes smoothly from the last number to the first.
do
  d1 "cp"
  d2 $ n (run 16 |% 8) # s "supervibe" # gain (smooth "<0.5 0.75 1>")

-- Smooth, but without smoothing from the last number to the first, and instead jumping back to the first.
let
gainLoop = seqPLoop [(0, 2, smooth "<0.5 0.75 1>")]
in do
  d1 "cp"
  d2 $ n (run 16 |% 8) # s "supervibe" # gain gainLoop

-- Ur vs. SeqPLoop for random patterns.
-- SeqPLoop repeats the same pattern over and over, whereas Ur chooses randomly.
let
gallop = fast 2 $ shuffle 2 $ slice 8 "0@3 2 . 0 2" $ loopAt 1 $ s "break:4"
in do
  d1 "cp"
  d2 $ seqPLoop [
    (0, 1, gallop)
    ]
  d2 $ ur 1 "gallop" [
    ("gallop", gallop)
    ] []

-- Round note to nearest.
-- These two examples are equivalent.
do
  d1 "cp"
  d2 $ n (segment 12 $ ((*2) . fromIntegral . floor) <$> ((irand 12) / 2)) # s "supervibe"  -- fromintegral because floor outputs Integral but n expects Note
  d2 $ n (segment 12 $ 2 * irand 6) # s "supervibe"

-- Inhabit.  Give patterns names, then call them from another pattern of Strings.
-- In this example, the names are simply numbers (0, 1, 2, 3) but as Strings.
let
chords = inhabit [
  ("0", "g4'maj'i1"),
  ("1", "d4'maj'i2"),
  ("2", "a3'dom7'i3"),
  ("3", "d4'maj'i1")
  ] "0 1 2 3"
in do
  d1 "cp"
  d2 $ n chords # s "violin"

-- Random notes, but hardcoded.
let
randOffset = (segment 1 $ (irand 11) - 5)
randNotes = loopFirst $ (fast 1.3 . irand) 8 + "7..0" -- Change the "fast" argument to generate a new random sequence.
in do
  d1 "cp"
  d2 $ n "c5" |+ n randOffset # s "superpiano" # gain 1
  d3 $ n (scale "minor" (segment "16|12|13|15|17" $ randNotes)) |+ n ("c6" + randOffset + (scale "minor" "0, -3, -5")) # s "violin" # gain 0.7

-- Nudge.  Shifts pattern in time.
do
  d1 "cp"
  d2 $ n "0 1 3 1" # s "supervibe" # nudge 0.15

-- Rangex.  Exponential version of Range.
-- For example, range 20 2000 "0.5" gives 1010 - halfway between 20 and 2000.
-- But rangex 20 2000 0.5 gives 200 - halfway between on a logarithmic scale.
do
  d1 "cp"
  d2 $ n (scale "minor" (run 16)) # s "supervibe" # gain (rangex 0.5 1.25 rand)

-- PickF.  Chooses between a list of functions, using a pattern of integers.
do
  d1 "cp"
  d2 $ pickF "0 . 1 2" [id, const silence, (# gain 1.25)] $ chop 8 $ loopAt 1 $ s "break:4"

-- SelectF.  Chooses between a list of functions, using a pattern of floats (from 0 to 1).
-- I can't think of a reason to use SelectF over PickF.  They seem identical, except that SelectF's integer indices are more PickF.
do
  d1 "cp"
  d2 $ selectF "0 . 0.34 0.67" [id, const silence, (# gain 1.25)] $ chop 8 $ loopAt 1 $ s "break:4"

-- RepeatCycles.  Repeat something for cycles?
-- Seems to work well with Inside and Outside functions.
do
  d1 "cp"
  d2 $ inside 2 (repeatCycles 2) $ n (segment 16 $ irand 13) # s "violin"










