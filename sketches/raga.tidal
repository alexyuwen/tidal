

-- Define the whole scale ascending and descending, then use bite.
-- To couple dynamics to ornaments, are binary patterns needed?
let
scale0 = scale "minor" $ "<[0 2] [3 4] [7 4] [3 2]>"
ornamentRhythm0 = "[0@2 1 0@2 1@0.8 0@1.9] !"
ornamentRhythm1 = "[0@4 1 . 0]*4"
ornamentRhythm2 = "[0@1.9 1]*8"
scaleUp0 = scale "minor" $ "<[0 2] [3 4]>" + ornamentRhythm0 * "<[2 1] [1 3]>"
scaleDown0 = scale "minor" $ "<[7 4] [3 2]>" + ornamentRhythm0 * "<[2 3] [1 1]>"
scaleUpDown0 = sew "<t t f f>" scaleUp0 scaleDown0
scaleUp1 = scale "minor" $ "0 2 3 4" + ornamentRhythm1 * "2 1 1 3"
scaleDown1 = scale "minor" $ "7 4 3 2" + ornamentRhythm1 * "2 3 1 1"
scaleUp2 = scale "minor" $ "[0 2 3 4] !" + ornamentRhythm2 * "[3 2 4 5] !"
scaleDown2 = scale "minor" $ "[7 4 3 2] !" + ornamentRhythm2 * "[2 3 1 1] !"
scale2 = fastcat [scaleUp2, scaleDown2]
-- nPat = n (select ((/5) <$> "<0 0 1 1 2 3 [4 5]>") [scaleUp0, scaleDown0, scaleUp1, scaleDown1, scaleUp2, scaleDown2]) |+ n "d5"
nPat = outside 4 (bite 8 $ "0 1 2 3 4 5 6 7") $ n (scaleUpDown0 + "d5")
-- Wrap nPat in seqPLoop so that on the loop, all patterns reset to the start.
nPat2 = seqPLoop [
  (0, 7, nPat)
  ]
in do
  setcps 0.6
  setCycle 0
  d1 $ "cp" # gain 0.8
  d2 $ nPat2 # s "violin" # vowel "u"




  -- Different set of ornaments.
  let
  -- ornaments
  ornamentRhythm0 = "[0@1.6 1@0.8 0@1.4 1@0.6 0@1.32] !"
  ornamentRhythm1 = "[0@0.8 1 0@0.66]*4"
  ornamentRhythm2 = "[0 1@1.1 0]*8"
  -- scale 0
  scaleUp0 = scale "minor" $ "<[0 2] [3 4]>" + ornamentRhythm0 * "<[2 1] [1 3]>"
  scaleDown0 = scale "minor" $ "<[7 4] [3 2]>" + ornamentRhythm0 * "<[2 3] [1 1]>"
  scale0 = sew "<t t f f>" scaleUp0 scaleDown0
  -- scale 1
  scaleUp1 = scale "minor" $ "0 2 3 4" + ornamentRhythm1 * "2 1 1 3"
  scaleDown1 = scale "minor" $ "7 4 3 2" + ornamentRhythm1 * "2 3 1 1"
  scale1 = cat [scaleUp1, scaleDown1]
  -- scale 2
  scaleUp2 = scale "minor" $ "[0 2 3 4] !" + ornamentRhythm2 * "[2 1 1 3] !"
  scaleDown2 = scale "minor" $ "[7 4 3 2] !" + ornamentRhythm2 * "[2 3 1 1] !"
  scale2 = sew "t f" scaleUp2 scaleDown2
  -- pats
  nPat = n (select ((/4) <$> "<0 0 1 1 2 3 4>") [scaleUp0, scaleDown0, scaleUp1, scaleDown1, scale2]) |+ n "d5"
  nPat2 = seqPLoop [ -- Wrap nPat in seqPLoop so that on the loop, all patterns reset to the start.
    (0, 7, nPat)
    ]
  -- offset scales
  scale0Offset = (~>) (1/4) $ scale0
  scale1Offset = (~>) (1/8) $ scale1
  scale2Pat = bite 8 ("[0..7]/3" + "[0 1 2]*8%3") scale2
  in do
    setcps 0.6
    setCycle 0
    d1 $ "hc" # gain 0.8
    d2 $ scale2Pat # s "sin"
    d2 $ select ((/2) <$> (segment 2 $ irand 3)) [scale0Offset, scale1Offset, scale2Pat] # s "sin"

