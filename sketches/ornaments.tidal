

-- Define the whole scale ascending and descending, then use bite.
-- Use timecat for uneven rhythm, unless better solution exists?
let
scale0 = scale "minor" $ "<[0 2] [3 4] [7 4] [3 2]>"
ornamentRhythm0 = "[0@2 1 0@2 1@0.8 0@1.9] !"
ornamentRhythm1 = "[0@4 1 . 0]*4"
ornamentRhythm2 = "[0@1.9 1]*8"
scaleUp0 = scale "minor" $ "<[0 2] [3 4]>" + ornamentRhythm0 * "<[2 1] [1 3]>"
scaleDown0 = scale "minor" $ "<[7 4] [3 2]>" + ornamentRhythm0 * "<[2 3] [1 1]>"
scaleUp1 = scale "minor" $ "0 2 3 4" + ornamentRhythm1 * "2 1 1 3"
scaleDown1 = scale "minor" $ "7 4 3 2" + ornamentRhythm1 * "2 3 1 1"
scaleUp2 = scale "minor" $ "[0 2 3 4] !" + ornamentRhythm2 * "[3 2 4 5] !"
scaleDown2 = scale "minor" $ "[7 4 3 2] !" + ornamentRhythm2 * "[2 3 1 1] !"
scale2 = fastcat [scaleUp2, scaleDown2]
nPat = n (select ((/5) <$> "<0 0 1 1 2 3 [4 5]>") [scaleUp0, scaleDown0, scaleUp1, scaleDown1, scaleUp2, scaleDown2]) |+ n "d5"
-- Wrap nPat in seqPLoop so that on the loop, all patterns reset to the start.
nPat2 = seqPLoop [
  (0, 7, nPat)
  ]
in do
  setcps 0.6
  setCycle 0
  d1 $ "cp" # gain 0.8
  d2 $ nPat2 # s "violin" # vowel "u"


-- Define the whole scale ascending and descending, then use bite.
-- Use timecat for uneven rhythm, unless better solution exists?
let
ornamentRhythm0 = "[0@2 1 0@2 1@0.8 0@1.9] !"
ornamentRhythm1 = "[0@4 1 . 0]*4"
ornamentRhythm2 = "[0@1.9 1]*8"
scaleUp0 = scale "minor" $ "<[0 2] [3 4]>" + ornamentRhythm0 * "<[2 1] [1 3]>"
scaleDown0 = scale "minor" $ "<[7 4] [3 2]>" + ornamentRhythm0 * "<[2 3] [1 1]>"
scaleUp1 = scale "minor" $ "0 2 3 4" + ornamentRhythm1 * "2 1 1 3"
scaleDown1 = scale "minor" $ "7 4 3 2" + ornamentRhythm1 * "2 3 1 1"
scaleUp2 = scale "minor" $ "[0 2 3 4]" + ornamentRhythm2 * "[3 2 4 5]"
scaleDown2 = scale "minor" $ "[7 4 3 2]" + ornamentRhythm2 * "[2 3 1 1]"
scale2 = fastcat [scaleUp2, scaleDown2]
nPat = n (select ((/5) <$> "<0 0 1 1 2 3 [4 5]>") [scaleUp0, scaleDown0, scaleUp1, scaleDown1, scaleUp2, scaleDown2]) |+ n "d5"
-- Wrap nPat in seqPLoop so that on the loop, all patterns reset to the start.
nPat2 = seqPLoop [
  (0, 7, nPat)
  ]
in do
  setcps 0.3
  setCycle 6
  d1 $ "cp" # gain 0.8
  d2 $ nPat # s "violin" # vowel "u"
  -- d2 $ bite 4 (shuffle 4 "0 1 2 3") (n scaleUp1) # s "superhammond"


:t fit

-- Ornaments.
let
notes = fast 2 <$> [
  (+ n "0 [0 1 . 0] 0 0") $ n (scale "major" "4 2 0 -3" |+ "d5"),
  (+ n "[0 -2 . 0] 0 0 0") $ n (scale "major" "2 4 7 9" |+ "g4"),
  (+ n "[2 0@2 2] 0 0 0") $ n (scale "major" "4 . 2 1" |+ "d5"),
  (+ n "0 . 0 [0 . -1 0]") $ n (scale "major" "0 . 2 3" |+ "d5"),
  n (scale "major" "2, 0, -3" |+ "d5"),
  (+ n "[1 0 _ 1] 0@3") $ n (scale "major" "1, -1, -3, -4" |+ "d5"),
  n (scale "major" "0, -3, -5" |+ "d5"),
  n (scale "major" "0, -3, -5" |+ "d5")
  ]
in do
  setcps 0.6
  setCycle 0
  d2 $ slow 4 $ fastcat notes # s "organTonewheel3, violin" # vowel "a"
  d2 $ ur 4 (segment (4 * 2) $ "p0 p1 p2 p3 p4 p5 p6@2") [
    ("p0", notes !! 0),
    ("p1", notes !! 1),
    ("p2", notes !! 2),
    ("p3", notes !! 3),
    ("p4", notes !! 4),
    ("p5", notes !! 5),
    ("p6", notes !! 6)
    ] [] # s "organTonewheel3, violin" # vowel "a"
