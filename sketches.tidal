do
  setcps (135/60/4)
  hush
  d1 $ "<1(3, 8, 6) [1(3, 8, 6) ~] [1 1(3, 8, 6)]>" # s "lt" # gain 2
  d2 $ fast 4 $ s "<[hc hc*2] [hc hc ~ hc] hc*2 [~ hc]*2>" # gain "[0.9 0.7]"
  d3 $ "cp"
  d4 $ ""



do
  setcps (135/60/4)
  hush
  d1 $ "bd" # gain 2
  d2 $ "hc*4"
  d4 $ wrandcat [("t([5|6|7], 12, 1)", 0.5), ("t([11], 36)", 0.5), ("~ ~ . t t", 0.1)] # s "ht" # vowel "a"
  -- d5 $ fast 6 $ s "hc hc*2" # vowel "e" # gain 0.77
  -- d6 $ "cp(<5 6 8 6>,24,2)" # vowel "i"



do
  setcps (135/60/5)
  d1 $ "bd" # gain 2
  d2 $ "hc*5" # vowel "o"
  d3 $ fast (5/2) $ "~ ~ ~ cp . ~ cp"
  d4 $ fast (5/4) $ "ht(10,16)" # vowel "o"



-- To use freq instead of n, make rand exponential using (hi - lo) * (rand^2) + lo
do
  d1 $ segment 24 $ n (12 * rand) # s "supervibe"
  d2 $ segment 1 $ n (12 * rand) |+ n "-12, 0, 12" # octave 4 # s "supervibe" # legato 1.5


-- Hc every so often.
do
  d1 $ "cp"
  d2 $ fast 8 $ every (segment 1 $ irand 8) (const $ s "hc") $ "~"

-- Time-shifting a break.
do
  d1 $ "cp"
  d2 $ someCyclesBy 0.2 (const silence) $ (<~) (cycleChoose [0, 1/4, 2/4, 3/4]) $ striate 4 $ loopAt 1 "break:1" # cut 1

-- Improvisation starting-point.
do
  d1 $ "cp"
  d2 $ slice 8 "{0 1 2 3 4 5 6 7}%8" $ loopAt 1 "break:1" # cut 1

-- Improvisation starting-point.
let
normalBreak = chop 16 $ loopAt 1 "break:1" # cut 1
fastBreak = hurry 1.5 $ chop 16 $ loopAt 1 "break:1" # cut 1
mixedBreak = wrandcat [
    (fastBreak, 3),
    (normalBreak, 5)
  ]
in do
  d1 $ "cp"
  d2 $ mixedBreak

-- Starting point.
do
  d1 $ striate 2 $ loopAt 1 $ s "break:1" # cut 1 * speed "1 2 1 1"
  d2 $ "cp"

-- Londynn.
let
loopAts = [ 9/x | x <- [4,5,6] ] -- List comprehension.  Note that [4..6] does not work.
in do
  d1 $ chop 1024 $ loopAt (stack $ loopAts) $ s "londynn" # hpf 1000
  d1 $ chop 1024 $ loopAt (2) $ s "londynn" -- The bass note is from the beginning of each cycle!
  d1 $ loopAt (stack $ loopAts) $ splice 1024 "177..1023" $ s "londynn"
  d1 $ chop 1024 $ loopAt 4 $ s "londynn"

-- Bass line.
let
gallop = fast 2 $ shuffle 2 $ stack [
  slice 8 "0@3 2 . 0 2" $ loopAt 1 $ s "break:4",
  n (scale "minor" "[0 . ~ -3] [0 ~ -3 ~]") # octave 3 # s "moogBass" # gain 1.8
  ]
in do
  d1 "cp"
  d2 $ gallop





-- Ornaments.
let
notes = fast 2 <$> [
  (+ n "0 [0 1 . 0] 0 0") $ n (scale "major" "4 2 0 -3" |+ "d5"),
  (+ n "[0 -2 . 0] 0 0 0") $ n (scale "major" "2 4 7 9" |+ "g4"),
  (+ n "[2 0@2 2] 0 0 0") $ n (scale "major" "4 . 2 1" |+ "d5"),
  (+ n "0 . 0 [0 . -1 0]") $ n (scale "major" "0 . 2 3" |+ "d5"),
  n (scale "major" "2, 0, -3" |+ "d5"),
  (+ n "[1 0 _ 1] 0@3") $ n (scale "major" "1, -1, -3, -4" |+ "d5"),
  n (scale "major" "0, -3, -5" |+ "d5"),
  n (scale "major" "0, -3, -5" |+ "d5")
  ]
in do
  d1 "cp"
  d2 $ slow 4 $ fastcat notes # s "organTonewheel3, violin" # vowel "a"
  d2 $ ur 4 (segment (4 * 2) $ "p0 p1 p2 p3 p4 p5 p6@2") [
    ("p0", notes !! 0),
    ("p1", notes !! 1),
    ("p2", notes !! 2),
    ("p3", notes !! 3),
    ("p4", notes !! 4),
    ("p5", notes !! 5),
    ("p6", notes !! 6)
    ] [] # s "organTonewheel3, violin" # vowel "a"



-- Violin fiddle.
let
tones = "1 2 3 0 . 1 2 1 0 . 1 0 1 2 . 3 2 1 0"
arpPat = n (bite 8 (scramble 4 tones) $ arpg $ "c4'min'8'i2")
scalePat = n (bite 4 (scramble 4 tones) $ (scale "minor" "-3 0 1 2"))
combinedPat = select (segment 2 $ irand 2) [arpPat, scalePat]
fastPat = fast 4 $ n (scale "minor" "0 [2 1 . 0]")
arpPatSlow = slow 4 $ n (bite 8 tones $ arpg $ "c4'min'8'i2")
drumStart = "[0 0 0?0.8 0?0.2]*4"
drumMiddle = "<[0|4] [2|4]>*8"
tetraChord = fastcat [
  n $ scale "minor" "0 1 2 4",
  n $ scale "minor" "0 1 2 4" + 12,
  n $ scale "minor" "0 1 2 4" + 24,
  n $ scale "minor" "0 1 2 _" + 36
  ]
melodyPat = select ((/2) <$> "<[[0|1|2] 1 0 1] [[0|1|2] 1 <0 1> <1 2>]>") [arpPat, scalePat, slow 2 $ (<~) (1/8) fastPat] # s "violin" # vowel "o"
melodiesPat = superimpose ((# octave 4) . (# gain 1.1) . (truncStart $ segment 1 $ range 0 0.8 rand) . (trunc $ segment 1 $ range 0.2 1 rand)) melodyPat
in do
  d1 $ "cp"
  d2 $ slow 4 $ n "c2" # s "organDonor" # gain 1.6
  d3 $ slice 8 (select ("0?0.1 1 1 [1?0.2 1]") [drumStart, drumMiddle]) $ loopAt 1 $ s "break:4" # cut 1 # gain "1.25 1.12@3"
  d4 $ select (segment 8 $ wchoose [(0, 4), (1, 1)]) [combinedPat, fastPat]
  d4 $ melodyPat








