let
tones = "1 2 3 0 . 1 2 1 0 . 1 0 1 2 . 3 2 1 0"
arpPat = n (bite 8 (scramble 4 tones) $ arpg $ "c4'min'8'i2")
scalePat = n (bite 4 (scramble 4 tones) $ (scale "minor" "-3 0 1 2"))
combinedPat = select (segment 2 $ irand 2) [arpPat, scalePat]
fastPat = fast 4 $ n (scale "minor" "0 [2 1 . 0]")
arpPatSlow = slow 4 $ n (bite 8 tones $ arpg $ "c4'min'8'i2")
drumStart = "[0 0 0?0.8 0?0.2]*4"
drumMiddle = "<[0|4] [2|4]>*8"
tetraChord = fastcat [
  n $ scale "minor" "0 1 2 4",
  n $ scale "minor" "0 1 2 4" + 12,
  n $ scale "minor" "0 1 2 4" + 24,
  n $ scale "minor" "0 1 2 _" + 36
  ]
in do
  d1 $ "cp"
  d2 $ slow 4 $ n "c2" # s "organDonor" # gain 1.6
  d3 $ slice 8 (select ("0?0.1 1 1 [1?0.2 1]") [drumStart, drumMiddle]) $ loopAt 1 $ s "break:4" # cut 1 # gain "1.25 1.12@3"
  d4 $ select (segment 8 $ wchoose [(0, 4), (1, 1)]) [combinedPat, fastPat]
  d4 $ select ((/2) <$> "<[[2|2|2|0|1] 1 0 1] [[2|2|2|0|1] 1 <0 1> <1 2>]>") [arpPat, scalePat, slow 2 $ (<~) (1/8) fastPat] # s "violin" # vowel "o"
  -- d4 $ while "f(3,8)" (ply 2) $ slow 2 $ n </1>(bite 4 tones $ (scale "minor" "-3 0 1 2")) # s "violin"
  -- d4 $ slow 4 $ n (bite 4 tones $ (scale "minor" "-3 0 1 2")) # s "violin"
  -- d4 $ select (segment 4 $ wchoose [(0, 5), (1, 1)]) [arpPatSlow, slow 2 $ fastPat # vowel "u"] # s "violin" -- Is it possible to alternate the wchoose with a another choose, as the index selection?






do
  d2 $ loopAt 1.2 $ "break:4"

-- Isolate segments of drum break.
-- 0 and 3 are same.  cymbal + bd on strong beats
-- 2 and 6 are same.  sd on strong beats
-- 1 and 4 are similar.  With 4, the accented offbeats are on sd, but with 1, they're on the bd
-- 5 and 7 are similar.  5 is more grounded, because at least bd marks the strong beats
let
m = 16
randSlice = irand $ div m 2
striateBeat = slow 2 $ striate 16 $ loopAt 1 $ s "break:4 !"
randBeat = slice m (stitch (fast (m/2) $ "t f") (2 * randSlice) (2 * randSlice + 1)) $ loopAt 1 $ s "break:4"
randBeatUr = ur 2 "randBeat" [
  ("randBeat", randBeat)
  ] []
randCymbals = slice 16 "[1|2|7|8|13|14]*16" $ loopAt 1 $ s "break:4"
in do
  d1 "cp"
  -- d2 $ n "c2" # s "organDonor" # gain 1.5
  d3 $ striateBeat
  d3 $ ur 4 "striateBeat _ _ _ . striateBeat _ _ _" [
    ("striateBeat", striateBeat),
    ("randBeat", randBeat)
    ] []








-- Build a solo like a story, using only two patterns: gallop and hemiolia.
let
hemiola = splice 8 (fast (8/3) $ "[0|0|2] 1 [5|7|7]") $ s "break:4"
gallop = fast 2 $ shuffle 2 $ slice 8 "0@3 2 . 0 2" $ loopAt 1 $ s "break:4"
time = slow 2 $ striate 16 $ loopAt 1 $ s "break:4 !"
silence = "~*8"
in do
  d1 "cp"
  d2 $ ur 1 "gallop" [
    ("gallop", gallop)
    ] []
  -- d2 $ ur 1 "hemiola" [
  --   ("hemiola", hemiola)
  --   ] []





-- Ornaments.
let
ornaments = fast 4 "[0.5 0 _ 0.5 . 0]"
melody = ply 2 $ n (slow 8 $ scale "major" "[0..7] . [6..1]@3 0") |+ n "d5" + n (sew "t f t f" "0" ornaments) # s "organTonewheel3"
chords = []
bass = []
in do
  d1 "cp"
  d2 $ melody





-- Random notes, but hardcoded.
let
randOffset = (segment 1 $ (irand 11) - 5)
randTones = loopFirst $ (fast 2.1 . irand) 8 + "7..0" -- Change the "fast" argument to generate a new random sequence.
randNotes = n (segment 8 $ scale "minor" randTones + ("c6" + randOffset))
fixedNotes = n (scale "minor" "0 2 4 7" + ("c6" + randOffset))
in do
  d1 "cp"
  d2 $ n "c5" |+ n randOffset # s "superpiano" # gain 1.2
  d3 $ randNotes # s "violin"
  d3 $ fastcat [fixedNotes, randNotes] # s "violin"
  d3 $ fixedNotes # s "violin"




do
  d1 "cp"
  d2 $ "[1@0.7 1]*4" # n (run 8) # s "violin"





