-- Const.
d1
$ every 6 (const("hc(6,8)*2"))
$ every 5 (const $ "hc!13")
$ every 2 (const $ "hc")
$ "hc(5, 7)"

-- Slice is for samples.  Bite is for patterns.
d1 $ slice 8 "0 2 4 6 6 0 6" $ s "break:1"

-- Randslice.  This example plays a random half of the sample each cycle.
d1 $ randslice 2 $ "break:1"

-- Scale.
d1 $ n (scale "minor" $ run 8) # s "supermandolin"

-- Scale in different key
d1 $ n (scale "minor" $ run 8) |+ n "d" # s "supermandolin"

-- Ply.  Repeats each event the given number of times.
d1 $ ply 2 $ n (scale "minor" "0 2 1 4") # s "supersaw" # legato 0.1 # lpf 800

-- Chords. These two examples are equivalent.
d1 $ arp "up" $ n "<c'maj bf'min>" |+ n "<0 -12>" # s "supermandolin"
d1 $ arp "up" $ n "<c'maj bf'min>" # octave "<5 4>" # s "supermandolin"

-- More than one arp per chord.
d1 $ arp "up down" $ ply 2 $ n "<c'maj'4 bf'min'4>" # octave "<5 4>" # s "supermandolin"

-- Custom scale.  These two examples are equivalent.
d1 $ slow 2 $ n (toScale [0,1.5,3,5,7,8.5,10] "0..7") # s "supervibe"

let scale = getScale (scaleTable ++ [("microtonal", [0,1.5,3,5,7,8.5,10])])
d1 $ slow 2 $ n (scale "microtonal" "0..7") # s "supervibe"

-- Custom chord.
let myChord = "[0,3.5,7]"
d1 $ rolled $ n myChord |+ n "<c5 bf4>" # s "supervibe"

-- Ur.
d1 $ ur 2 "p1 p2 . p1:e1 p2:e1"
[
("p1", s "bd"),
("p2", s "cp")
]
[
("e1", (# squiz 3))
]

-- Fit.  Plays from a list according to the sequence of indexes, but starts from a different index each cycle.
d1 $ n (fit 1 [0, 1, 4, 7] "0 1 2 3 0") # s "supervibe"

-- Random pitches.
d1 $ segment 16 $ n (10 * rand) # s "supervibe" # legato 0.5

-- Random pitches in a scale.
d1 $ segment 8 $ n (scale "minor" $ irand 8) # s "supervibe" # legato 0.5

-- Math on rand.
d1 $ rolledBy (0.75 * rand^2 + 0.25) $ n "df'maj'5" # s "supervibe" # room 0.5 -- For x between 0 and 1, y is between 0.25 and 1, favoring the bottom

-- Decoupling multiple rands, because rand is a deterministic function of time.
-- In the first example, all the high pitches are in the right speaker.  In the second example, pitch is decoupled from panning.
d1 $ segment 16 $ n (24 * rand) # s "supervibe" # pan rand
d1 $ segment 16 $ n (24 * rand) # s "supervibe" # pan (slow 1.1 rand)

-- Randomly drop events with question mark.
d1 $ fast 2 $ stack [
"bd?0.2 bd" # squiz 3 # gain 2,
"~!3 cp . ~ cp?0.2"
]

-- Randomly drop events with degrade and degradeBy
d1 $ degradeBy 0.2 $ fast 4 $ "1 . 1 1" # s "glockenspiel:-24" # legato 0.8

-- Sometimes.
d1 $ "1*16" # (sometimes (|+ n 12) $ n (range 0 6 rand)) # s "supervibe"

-- Somecycles.
d2 $ somecycles (fast 2) $ "glockenspiel:-24(5,8)"

-- Scramble: sampling with replacement.
d2 $ scramble 2 $ stack [
 "1 1*2 . 1 1 ~ 1" # s "hc",
 "1 . 1 1" # s "bd" # squiz 2 # gain 2
]

-- Shuffle: sampling without replacement.
d1 $ shuffle 4 $ stack [
 "1 1*2 . 1 1 ~ 1" # s "hc",
 "1 . 1 1" # s "bd" # squiz 2 # gain 2
]

-- All the chords.
import Sound.Tidal.Chords
chordList

-- Choose. By itself, it produces a continuous stream, with no structure.
-- With choose, the parameters to choose from are a list of values, not patterns, so you can't normally use mininotation there.
-- A supposed workaround is innerJoin but that doesn't seem to work.
d1 $ rolledBy (choose [0.25, 0.5, 0.7]) $ n "df'maj'5" # s "supervibe" # room 0.5

-- Segment + choose.
d1 $ segment 16 $ n (6 * rand) |+ n (segment 3 $ choose [0, 10, 20]) # s "supervibe" # legato 0.5

-- Wchoose.
d1 $ segment 16 $ n (scale "minor" (wchoose [(0, 6), (2, 2), (4, 2), (7, 2)])) # s "supervibe"

-- CycleChoose.  Choose, but once per cycle.
d1 $ n "0 0 1 1 2 2 1 1" # s "supersaw" # lpf (cycleChoose [400, 1200, 3600])

-- ChooseBy.  Choose, but instead of selecting elements of the list randomly, it uses the given pattern to select elements.
-- At first glance, this functions seems unwieldy to me.
d1 $ n (chooseBy "0 0.2 0.4 0.6 0.8" [0..3]) # s "supervibe" -- 0 <= x < 0.25 maps to 0, 0.25 <= x < 0.5 maps to 1, etc.  x > 1 wraps around: only the decimal matters.

-- Cat.
d1 $ cat ["hc(3,8)", "hc(9,16,7)"]

-- Randcat.
d1 $ randcat ["sd", "sd(3,8)", "sd(9,16)"]

-- Wrandcat.
d1 $ wrandcat [
("sd", 1),
("sd sd", 2),
("sd(3,8)", 3)
]

-- SeqPLoop.
d1 $ seqPLoop [
(0, 2, "bd bd" # gain 2),
(2, 4, "bd(3,8)" # gain 2),
(4, 6, "bd(5,8)" # gain 2),
(1, 3, euclidInv 6 16 "hc"),
(3.5, 5, "hc!8")
]

-- Time shifting using <~ and ~>.  The arrow direction indicates which way the pattern shifts.
d1 $ every 2 ((1/8) <~) $ n (scale "minor" "0 3 1 2") # s "supervibe"

-- Ratio shorthand (mini notation) using %.
-- These three examples are equivalent.
d1 $ "supervibe:0*8" # cps ("<8%10 16%10>")
d1 $ "supervibe:0*8" # cps (cat [0.8, 1.6]) -- Here, cat is used to cycle through values each cycle.

-- Freq.
d1 $ segment 16 $ freq (range 200 240 rand) |* freq "1 2" # s "supervibe"

-- Polymeter using curly braces.  The base rhythm comes from the left (the first pattern).
d1 $ n "{0 1 -2, 7 12}" # s "supervibe"

-- Polyrhythm.
-- These two examples are identical.
d1 $ n "{0 1 -2}%8" # s "supervibe"
d1 $ n "{~!8, 0 1 -2}" # s "supervibe"  -- Note the exclamation mark.  Asterisk will not work.

-- Speeding up/down oscillators.
d1 $ segment 16 $ n (fast 1.5 $ range 0 20 sine) # s "supersaw" # lpf 999 -- Notice that every three waves (two cycles), the pitches repeat.

-- Euclidean offset using time shifting operator.
-- Here are three different options to avoid having <~ next to $.
d1 $ ((1/8) <~) $ euclid 3 8 $ s "cp"
d1 $ (1/8) <~ (euclid 3 8 $ s "cp")
d1 $ (<~) (1/8) $ (euclid 3 8 $ s "cp") -- Wrapping <~ in parentheses turns it into a normal function with arguments on the right-hand side

-- Random Euclidean offset.
-- These three examples are equivalent.
let fractions = [n / 8 | n <- [0 .. 7]]
in do
d1 $ (<~) (cycleChoose fractions) $ (euclid 3 8 $ s "cp")
d1 $ (<~) (cycleChoose [0, 1/8 .. 7/8]) $ (euclid 3 8 $ s "cp")
d1 $ (<~) ((segment 1 $ irand 8) / 8) $ euclid 3 8 $ s "cp"

-- EuclidInv and EuclidFull.
-- These two examples are equivalent.
d1 $ stack [(euclid 6 16 "bd" # gain 2), (euclidInv 6 16 "hc")]
d1 $ euclidFull 6 16 ("bd" # gain 2) "hc"

-- Perlin.  Generates a new random value to move to every cycle, but moves smoothly between each value.
d1 $ segment 16 $ n (fast 4 $ range 0 20 perlin) # s "supersaw" # lpf 999

-- Pattern composition using dot.
d1 $ every 2 ((<~) 0.125 . rev) $ n (scale "minor" "0 1 2 1") # s "supervibe"

-- MarkovPat.  Its three arguments are: sequence length, start index, and matrix.
-- Sequence length of n means 1/n of a cycle.  Only integer sequence length allowed, so each pattern cannot exceed one cycle.
-- In Haskell, !! is the list indexing operator.  It takes a list on the left-hand and an int on the right, and returns the item at that index.
d1 $ s $ fmap (["bd", "sd", "clap"]!!)
       $ markovPat 4 0 [
           [0.1,  0.7, 0.2],
           [0.15, 0.1, 0.8],
           [0.5,  0.3, 0.4]
         ]

-- FastGap.  Rather than it playing multiple times as fast would, it instead leaves a gap in the remaining space of the cycle.
d1 $ fastGap (segment 0.5 $ rand / 2 + 1) $ segment 10 $ n (12 * rand) # s "supervibe" # gain 1.4

-- Compress.  Squeezes the pattern into a time span.
d2 $ compress (1/4, 1) $ s "hc(6,8)"

-- Zoom.  Plays a portion of a pattern over the time period of the original pattern.
d2 $ every 3 (zoom (0.25, 1)) $ s "hc(9,12)"

-- Within.  Applies a function to only a part of a pattern.
d2 $ within (0, 0.1) (fast 2) $ s "hc*8"

-- Stretch.  Zooms in on a pattern to avoid silences at the start or end.
d1 $ note (stretch "~ <0 ~> 1 5 8*4 ~") # s "superpiano"

-- Superimpose.  Applies a function to a pattern, superimposed on the original pattern.
d1 $ superimpose (|+ n "12") $ n "0" # s "supervibe"

-- Off.  Superimpose, but with a time offset for the transformed pattern.
d1 $ off 0.1 (|+ n "12") $ n "0" # s "supervibe"

-- Press.  delays a sound for half the time in its slot.  Turns every instance of a into [~ a].
-- Every beat becomes an offbeat, so the overall effect is to syncopate a pattern.
d2 $ press $ slow 2 $ "bd cp [bd bd] cp"

-- PressBy.  Press, but with a variable time offset.
d2 $ slow 2 $ pressBy "<0 0.5>" $ "bd cp [bd bd] cp"

-- Rev.  Reverses a pattern.
d2 $ every 3 rev $ "bd cp [~ bd] cp"

-- Jux.  Applies a function to a pattern, but only in the right-hand channel.
d1 $ jux (+| n "-12, 12") $ segment "9|12" $ n (12 * rand) # s "supervibe"

-- JuxBy.  Jux, but instead of panned at a hard 0 and 1, specify how much to pan.
-- JuxBy 1 = Jux = pan at 0 and 1
-- JuxBy 0.5 = pan at 0.25 and 0.75
-- JuxBy 0 = pan at 0.5 and 0.5
d1 $ juxBy 0.5 (+| n "-12, 12") $ segment "9|12" $ n (12 * rand) # s "supervibe"

-- SwingBy.  The function swingBy x n breaks each cycle into n slices, then delays events in the second half of each slice by x.
-- These two examples are equivalent.  Swing = SwingBy (1/3)
d1 $ swingBy (1/3) 4 $ sound "hh*8"
d1 $ swing 4 $ sound "hh*8"

-- Echo.  Specify the number or echoes, the time between echoes in cycles, and the volume dropoff per echo.
d2 $ echo 3 0.2 0.7 $ sound "cp"
d2 $ echo 3 (-0.2) 0.7 $ sound "cp" -- Reverse echo.  Echo before the note instead of after.

-- EchoWith.  Echo, but with a custom function applied to each echo, not limited to volume.
-- Also, unlike Echo, the first argument of EchoWith includes the base event.
-- Note: A function like "|+ n ..." piles the function on top for each echo, which is probably unintended.
d1 $ echoWith 4 (1/8) (# octave 2) $ sound "supervibe" # n "0"

-- FoldEvery.  Essentially, chains multiple every functions together.
-- If a particular cycle is the start of more than one of the given cycle periods, then the function is applied more than once.
-- These three examples are equivalent.
d1 $ foldEvery [2,3] (ply 2) $ n (scale "minor" "0 2 1 4") # s "supervibe"
d1 $ every 2 (ply 2) $ every 3 (ply 2) $ n (scale "minor" "0 2 1 4") # s "supervibe"
d1 $ (every 2 (ply 2) . every 3 (ply 2)) $ n (scale "minor" "0 2 1 4") # s "supervibe"

-- Fix. Applies function to matching events in a pattern of controls. Fix is contrast where the false-branching function is set to the identity id.
d1 $ fix (# octave 6) (n (scale "minor" "[0, 4, 7]")) $ n (scale "minor" "0..7") # s "supervibe"

-- Unfix.  Fix, but applies function only when the testing pattern is not a match.
d1 $ unfix (# octave 6) (n (scale "minor" "[0, 4, 7]")) $ n (scale "minor" "0..7") # s "supervibe"

-- Contrast.  Basically an if-else-statement over patterns.  For contrast t f p, think of t as the true-branch, f as the false branch, and p as the test.
-- These two examples are equivalent.
d1 $ contrast (# octave 6) (# legato 0.3) (n (scale "minor" "[0, 4, 7]")) $ n (scale "minor" "0..7") # s "supervibe"
d1 $ contrastBy (==) (# octave 6) (# legato 0.3) (n (scale "minor" "[0, 4, 7]")) $ n (scale "minor" "0..7") # s "supervibe"

-- ContrastBy.  A more general version of contrast that takes an abritrary boolean function that is used to compare the control patterns.
d1 $ contrastBy (>=) (# octave 6) (# legato 0.3) (n (scale "minor" 2)) $ n (scale "minor" "0..7") # s "supervibe" -- Applies true-branch if 2 >= note



















